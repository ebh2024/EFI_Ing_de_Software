from django import forms
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth.models import User
from django.core.exceptions import ValidationError
from .models import Flight, Airplane, Passenger, Seat, Reservation, Ticket, SeatLayout, SeatType, SeatLayoutPosition
from django.utils import timezone
import datetime
import uuid

class AirplaneForm(forms.ModelForm):
    class Meta:
        model = Airplane
        fields = ['model_name', 'manufacturer', 'registration_number', 'year_of_manufacture', 'capacity', 'seat_layout', 'last_maintenance_date', 'technical_notes']
        widgets = {
            'last_maintenance_date': forms.DateInput(attrs={'type': 'date'}),
            'technical_notes': forms.Textarea(attrs={'rows': 4}),
        }

class SeatLayoutForm(forms.ModelForm):
    class Meta:
        model = SeatLayout
        fields = ['layout_name', 'rows', 'columns']

class SeatTypeForm(forms.ModelForm):
    class Meta:
        model = SeatType
        fields = ['name', 'code', 'price_multiplier']

class SeatLayoutPositionForm(forms.ModelForm):
    class Meta:
        model = SeatLayoutPosition
        fields = ['seat_layout', 'seat_type', 'row', 'column']

class CustomUserCreationForm(UserCreationForm):
    email = forms.EmailField(required=True, label="Email")

    class Meta(UserCreationForm.Meta):
        model = User
        fields = UserCreationForm.Meta.fields + ('email',)

    def clean_email(self):
        email = self.cleaned_data.get('email')
        if User.objects.filter(email=email).exists():
            raise ValidationError("This email address is already in use.")
        return email

    def clean_password2(self):
        password = self.cleaned_data.get('password')
        password2 = self.cleaned_data.get('password2')
        if password and password2 and password != password2:
            raise forms.ValidationError("The two password fields didn't match.")
        return password2

class CustomAuthenticationForm(AuthenticationForm):
    username = forms.CharField(label="Username")
    password = forms.CharField(label="Password", widget=forms.PasswordInput)

class FlightForm(forms.ModelForm):
    departure_date = forms.DateTimeField(
        widget=forms.DateTimeInput(attrs={'type': 'datetime-local'}),
        input_formats=['%Y-%m-%dT%H:%M']
    )
    arrival_date = forms.DateTimeField(
        widget=forms.DateTimeInput(attrs={'type': 'datetime-local'}),
        input_formats=['%Y-%m-%dT%H:%M']
    )

    class Meta:
        model = Flight
        fields = ['airplane', 'origin', 'destination', 'departure_date', 'arrival_date', 'duration', 'status', 'base_price']
        widgets = {
            'duration': forms.TextInput(attrs={'placeholder': 'HH:MM:SS'}),
        }

class PassengerForm(forms.ModelForm):
    class Meta:
        model = Passenger
        fields = ['first_name', 'last_name', 'document_number', 'email', 'phone', 'date_of_birth', 'document_type']
        widgets = {
            'date_of_birth': forms.DateInput(attrs={'type': 'date'}),
        }

class ReservationForm(forms.ModelForm):
    class Meta:
        model = Reservation
        fields = ['flight', 'seat', 'status', 'price'] # Removed 'passenger' as it's set by the view
        widgets = {
            'status': forms.HiddenInput(), # Status will be set by the view
            'price': forms.HiddenInput(),  # Price will be calculated by the view
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Optionally, filter seats based on the selected flight if flight is already known
        if 'flight' in self.initial:
            self.fields['seat'].queryset = Seat.objects.filter(airplane=self.initial['flight'].airplane, status='Available')
        else:
            self.fields['seat'].queryset = Seat.objects.none() # No seats initially

class TicketForm(forms.ModelForm):
    class Meta:
        model = Ticket
        fields = ['reservation', 'barcode', 'status']
        widgets = {
            'barcode': forms.HiddenInput(), # Barcode will be generated by the view
            'status': forms.HiddenInput(),  # Status will be set by the view
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if not self.instance.pk: # Only generate barcode for new tickets
            self.initial['barcode'] = str(uuid.uuid4()).replace('-', '')[:20] # Generate a unique barcode
        self.fields['reservation'].queryset = Reservation.objects.filter(status='CON') # Only allow confirmed reservations
